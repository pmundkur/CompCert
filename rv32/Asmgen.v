(* *********************************************************************)
(*                                                                     *)
(*              The Compcert verified compiler                         *)
(*                                                                     *)
(*          Xavier Leroy, INRIA Paris-Rocquencourt                     *)
(*                                                                     *)
(*  Copyright Institut National de Recherche en Informatique et en     *)
(*  Automatique.  All rights reserved.  This file is distributed       *)
(*  under the terms of the INRIA Non-Commercial License Agreement.     *)
(*                                                                     *)
(* *********************************************************************)

(* Adapted for RV32G by Prashanth Mundkur, SRI International. *)

(** Translation from Mach to RISC-V. *)

Require Import Coqlib.
Require Import Errors.
Require Import AST.
Require Import Integers.
Require Import Floats.
Require Import Op.
Require Import Locations.
Require Import Mach.
Require Import Asm.

Open Local Scope string_scope.
Open Local Scope error_monad_scope.

(** The code generation functions take advantage of several
  characteristics of the [Mach] code generated by earlier passes of the
  compiler, mostly that argument and result registers are of the correct
  types.  These properties are true by construction, but it's easier to
  recheck them during code generation and fail if they do not hold. *)

(** Extracting integer or float registers. *)

Definition ireg_of (r: mreg) : res ireg :=
  match preg_of r with IR mr => OK mr | _ => Error(msg "Asmgen.ireg_of") end.

Definition freg_of (r: mreg) : res freg :=
  match preg_of r with FR mr => OK mr | _ => Error(msg "Asmgen.freg_of") end.

(** Decomposition of integer constants.  They are split into either
  small signed immediates that fit in 12-bits, or, if they do not fit,
  into a (20-bit hi, 12-bit lo) pair where lo is sign-extended. *)

Inductive immed : Type :=
  | Imm_single (imm: int)
  | Imm_pair   (hi: int) (lo: int).

Definition make_immed (val: int) :=
  let discr := Int.shr val (Int.repr 11) in
  let hi    := Int.shru val (Int.repr 12) in
  if Int.eq discr Int.zero || Int.eq discr Int.mone
  then Imm_single val
  else Imm_pair (Int.add hi (Int.and discr Int.one)) (Int.sign_ext 12 val).

(** Temporary register selection. *)
Definition int_temp_for (r: mreg) :=
  if mreg_eq r R5 then R6 else R5.

(** Smart constructors for arithmetic operations involving
  a 32-bit integer constant.  Depending on whether the
  constant fits in 12 bits or not, one or several instructions
  are generated as required to perform the operation
  and prepended to the given instruction sequence [k]. *)

Definition load_hilo (r: ireg) (hi lo: int) k :=
  if Int.eq lo Int.zero then Plui r hi :: k
  else Plui r hi :: Paddi r r lo :: k.

Definition load_hibase (rd base: ireg) (hi: int) k :=
  Plui rd hi :: Padd rd rd base :: k.

Definition loadimm (r: ireg) (n: int) (k: code) :=
  match make_immed n with
  | Imm_single imm => Pseti r imm :: k
  | Imm_pair hi lo => load_hilo r hi lo k
  end.

Definition addimm (rd: ireg) (rs: ireg) (n: int) (tmp: ireg) (k: code) :=
  match make_immed n with
  | Imm_single imm => Paddi rd rs n :: k
  | Imm_pair hi lo => load_hilo tmp hi lo (Padd rd rs tmp :: k)
  end.

Definition andimm (rd: ireg) (rs: ireg) (n: int) (tmp: ireg) (k: code) :=
  match make_immed n with
  | Imm_single imm => Pandi rd rs n :: k
  | Imm_pair hi lo => load_hilo tmp hi lo (Pand rd rs tmp :: k)
  end.

Definition orimm (rd: ireg) (rs: ireg) (n: int) (tmp: ireg) (k: code) :=
  match make_immed n with
  | Imm_single imm => Pori rd rs n :: k
  | Imm_pair hi lo => load_hilo tmp hi lo (Por rd rs tmp :: k)
  end.

Definition xorimm (rd: ireg) (rs: ireg) (n: int) (tmp: ireg) (k: code) :=
  match make_immed n with
  | Imm_single imm => Pxori rd rs n :: k
  | Imm_pair hi lo => load_hilo tmp hi lo (Pxor rd rs tmp :: k)
  end.

(** Translation of a condition operator with no immediate arguments.
  The generated code sets the [r] target register to 0 or 1 depending
  on the truth value of the condition.

  The translation is split into functions that handle the immediate
  and non-immediate versions of the operators.  *)

Definition transl_cond_int
           (cond: condition) (a1 a2: mreg) (lbl: label) (k: code) :=
  do rs1 <- ireg_of a1; do rs2 <- ireg_of a2;
  match cond with
  | Ccomp  Ceq => OK (Pbeq  rs1 rs2 lbl :: k)
  | Ccomp  Cne => OK (Pbne  rs1 rs2 lbl :: k)
  | Ccomp  Clt => OK (Pblt  rs1 rs2 lbl :: k)
  | Ccomp  Cle => OK (Pbge  rs2 rs1 lbl :: k)
  | Ccomp  Cgt => OK (Pblt  rs2 rs1 lbl :: k)
  | Ccomp  Cge => OK (Pbge  rs1 rs2 lbl :: k)

  | Ccompu Ceq => OK (Pbequ rs1 rs2 lbl :: k)
  | Ccompu Cne => OK (Pbneu rs1 rs2 lbl :: k)
  | Ccompu Clt => OK (Pbltu rs1 rs2 lbl :: k)
  | Ccompu Cle => OK (Pbgeu rs2 rs1 lbl :: k)
  | Ccompu Cgt => OK (Pbltu rs2 rs1 lbl :: k)
  | Ccompu Cge => OK (Pbgeu rs1 rs2 lbl :: k)

  | _ => Error(msg "Asmgen.transl_cond_int")
  end.

Definition transl_cond_float
           (c: comparison) (r: mreg) (f1 f2: mreg) (k: code) :=
  do rd <- ireg_of r; do fs1 <- freg_of f1; do fs2 <- freg_of f2;
  match c with
  | Ceq => OK (Pfeqd rd fs1 fs2 :: k)
  | Cne => OK (Pfeqd rd fs1 fs2 :: Pxori rd rd Int.one :: k)
  | Clt => OK (Pfltd rd fs1 fs2 :: k)
  | Cle => OK (Pfled rd fs1 fs2 :: k)
  | Cgt => OK (Pfltd rd fs2 fs1 :: k)
  | Cge => OK (Pfled rd fs2 fs1 :: k)
  end.

Definition transl_cond_single
           (c: comparison) (r: mreg) (f1 f2: mreg) (k: code) :=
  do rd <- ireg_of r; do fs1 <- freg_of f1; do fs2 <- freg_of f2;
  match c with
  | Ceq => OK (Pfeqs rd fs1 fs2 :: k)
  | Cne => OK (Pfeqs rd fs1 fs2 :: Pxori rd rd Int.one :: k)
  | Clt => OK (Pflts rd fs1 fs2 :: k)
  | Cle => OK (Pfles rd fs1 fs2 :: k)
  | Cgt => OK (Pflts rd fs2 fs1 :: k)
  | Cge => OK (Pfles rd fs2 fs1 :: k)
  end.

Definition transl_cond
           (cond: condition) (args: list mreg) (lbl: label) (k: code) :=
  match cond, args with
  | Ccomp  _, a1 :: a2 :: nil
  | Ccompu _, a1 :: a2 :: nil =>
      transl_cond_int cond a1 a2 lbl k

  | Ccompimm c n, a1 :: nil =>
      let tmp_mr := int_temp_for a1 in
      do tmp_ir <- ireg_of tmp_mr;
      do k' <- transl_cond_int (Ccomp c) a1 tmp_mr lbl k;
      OK (loadimm tmp_ir n k')
  | Ccompuimm c n, a1 :: nil =>
      let tmp_mr := int_temp_for a1 in
      do tmp_ir <- ireg_of tmp_mr;
      do k' <- transl_cond_int (Ccompu c) a1 tmp_mr lbl k;
      OK (loadimm tmp_ir n k')

  | Ccompf c, f1 :: f2 :: nil =>
      transl_cond_float c R5 f1 f2 (Pbnez X5 lbl :: k)
  | Cnotcompf c, f1 :: f2 :: nil =>
      transl_cond_float c R5 f1 f2 (Pbeqz X5 lbl :: k)

  | Ccompfs c, f1 :: f2 :: nil =>
      transl_cond_single c R5 f1 f2 (Pbnez X5 lbl :: k)
  | Cnotcompfs c, f1 :: f2 :: nil =>
      transl_cond_single c R5 f1 f2 (Pbeqz X5 lbl :: k)

  | _, _ =>
      Error(msg "Asmgen.transl_cond")
  end.

(** Translation of the arithmetic operation [r <- op(args)].
  The corresponding instructions are prepended to [k]. *)

Definition transl_cond_op_int (cond: condition) (s1 s2 d: mreg) (k: code) :=
  do rs1 <- ireg_of s1; do rs2 <- ireg_of s2; do rd <- ireg_of d;
  match cond with
  | Ccomp  Ceq => OK (Pxor  rd rs1 rs2 :: Pseqz rd rd :: k)
  | Ccomp  Cne => OK (Pxor  rd rs1 rs2 :: Psnez rd rd :: k)
  | Ccomp  Clt => OK (Pslt  rd rs1 rs2 :: k)
  | Ccomp  Cle => OK (Pslt  rd rs2 rs1 :: Pxori rd rd Int.one :: k)
  | Ccomp  Cgt => OK (Pslt  rd rs2 rs1 :: k)
  | Ccomp  Cge => OK (Pslt  rd rs1 rs2 :: Pxori rd rd Int.one :: k)

  | Ccompu Ceq => OK (Pequ  rd rs1 rs2 :: k)
  | Ccompu Cne => OK (Pneu  rd rs1 rs2 :: k)
  | Ccompu Clt => OK (Psltu rd rs1 rs2 :: k)
  | Ccompu Cle => OK (Psltu rd rs2 rs1 :: Pxori rd rd Int.one :: k)
  | Ccompu Cgt => OK (Psltu rd rs2 rs1 :: k)
  | Ccompu Cge => OK (Psltu rd rs1 rs2 :: Pxori rd rd Int.one :: k)

  | _ => Error(msg "Asmgen.transl_cond_op_int")
  end.

Definition transl_cond_op
           (cond: condition) (args: list mreg) (rd: mreg) (k: code) :=
  match cond, args with
    | Ccomp  _, a1 :: a2 :: nil
    | Ccompu _, a1 :: a2 :: nil =>
        transl_cond_op_int cond a1 a2 rd k

    (* TODO: use SLTI/SLTIU when possible *)
    | Ccompimm c n, a1 :: nil =>
        let tmr := int_temp_for a1 in
        do tir  <- ireg_of tmr;
        do k'   <- transl_cond_op_int (Ccomp c) a1 tmr rd k;
        OK (loadimm tir n k')
    | Ccompuimm c n, a1 :: nil =>
        let tmr := int_temp_for a1 in
        do tir  <- ireg_of tmr;
        do k'   <- transl_cond_op_int (Ccompu c) a1 tmr rd k;
        OK (loadimm tir n k')

    | Ccompf c, f1 :: f2 :: nil =>
        transl_cond_float c rd f1 f2 k
    | Cnotcompf c, f1 :: f2 :: nil =>
        do d <- ireg_of rd;
        transl_cond_float c rd f1 f2 (Pxori d d Int.one :: k)

    | Ccompfs c, f1 :: f2 :: nil =>
        transl_cond_single c rd f1 f2 k
    | Cnotcompfs c, f1 :: f2 :: nil =>
        do d <- ireg_of rd;
        transl_cond_single c rd f1 f2 (Pxori d d Int.one :: k)

    | _, _ =>
        Error(msg "Asmgen.transl_cond_op")
  end.

Definition transl_op
              (op: operation) (args: list mreg) (res: mreg) (k: code) :=
  match op, args with
  | Omove, a1 :: nil =>
      match preg_of res, preg_of a1 with
      | IR r, IR a => OK (Pmv r a :: k)
      | FR r, FR a => OK (Pfmv r a :: k)
      |  _  ,  _   => Error(msg "Asmgen.Omove")
      end

  | Ointconst n, nil =>
      do rd <- ireg_of res;
      OK (loadimm rd n k)
  | Ofloatconst f, nil =>
      do rd <- freg_of res;
      OK (Ploadfi rd f :: k)
  | Osingleconst f, nil =>
      do rd <- freg_of res;
      OK (Ploadsi rd f :: k)
  | Oaddrsymbol s ofs, nil =>
      do rd <- ireg_of res;
      OK (Ploadsymbol rd s ofs :: k)
  | Oaddrstack n, nil =>
      do rd <- ireg_of res;
      OK (addimm rd SP n X5 k)

  | Oadd, a1 :: a2 :: nil =>
      do rd <- ireg_of res; do rs1 <- ireg_of a1; do rs2 <- ireg_of a2;
      OK (Padd rd rs1 rs2 :: k)
  | Oaddimm n, a1 :: nil =>
      do rd  <- ireg_of res; do rs <- ireg_of a1;
      do tmp <- ireg_of (int_temp_for a1);
      OK (addimm rd rs n tmp k)
  | Osub, a1 :: a2 :: nil =>
      do rd <- ireg_of res; do rs1 <- ireg_of a1; do rs2 <- ireg_of a2;
      OK (Psub rd rs1 rs2 :: k)
  | Omul, a1 :: a2 :: nil =>
      do rd <- ireg_of res; do rs1 <- ireg_of a1; do rs2 <- ireg_of a2;
      OK (Pmul rd rs1 rs2 :: k)
  | Omulhs, a1 :: a2 :: nil =>
      do rd <- ireg_of res; do rs1 <- ireg_of a1; do rs2 <- ireg_of a2;
      OK (Pmulh rd rs1 rs2 :: k)
  | Omulhu, a1 :: a2 :: nil =>
      do rd <- ireg_of res; do rs1 <- ireg_of a1; do rs2 <- ireg_of a2;
      OK (Pmulhu rd rs1 rs2 :: k)
  | Odiv, a1 :: a2 :: nil =>
      do rd <- ireg_of res; do rs1 <- ireg_of a1; do rs2 <- ireg_of a2;
      OK (Pdiv rd rs1 rs2 :: k)
  | Odivu, a1 :: a2 :: nil =>
      do rd <- ireg_of res; do rs1 <- ireg_of a1; do rs2 <- ireg_of a2;
      OK (Pdivu rd rs1 rs2 :: k)
  | Omod, a1 :: a2 :: nil =>
      do rd <- ireg_of res; do rs1 <- ireg_of a1; do rs2 <- ireg_of a2;
      OK (Prem rd rs1 rs2 :: k)
  | Omodu, a1 :: a2 :: nil =>
      do rd <- ireg_of res; do rs1 <- ireg_of a1; do rs2 <- ireg_of a2;
      OK (Premu rd rs1 rs2 :: k)
  | Oand, a1 :: a2 :: nil =>
      do rd <- ireg_of res; do rs1 <- ireg_of a1; do rs2 <- ireg_of a2;
      OK (Pand rd rs1 rs2 :: k)
  | Oandimm n, a1 :: nil =>
      do rd  <- ireg_of res; do rs <- ireg_of a1;
      do tmp <- ireg_of (int_temp_for a1);
      OK (andimm rd rs n tmp k)
  | Oor, a1 :: a2 :: nil =>
      do rd <- ireg_of res; do rs1 <- ireg_of a1; do rs2 <- ireg_of a2;
      OK (Por rd rs1 rs2 :: k)
  | Oorimm n, a1 :: nil =>
      do rd  <- ireg_of res; do rs <- ireg_of a1;
      do tmp <- ireg_of (int_temp_for a1);
      OK (orimm rd rs n tmp k)
  | Oxor, a1 :: a2 :: nil =>
      do rd <- ireg_of res; do rs1 <- ireg_of a1; do rs2 <- ireg_of a2;
      OK (Pxor rd rs1 rs2 :: k)
  | Oxorimm n, a1 :: nil =>
      do rd  <- ireg_of res; do rs <- ireg_of a1;
      do tmp <- ireg_of (int_temp_for a1);
      OK (xorimm rd rs n tmp k)
  | Onot, a1 :: nil =>
      do rd <- ireg_of res; do rs <- ireg_of a1;
      OK (Pnot rd rs :: k)
  | Oshl, a1 :: a2 :: nil =>
      do rd <- ireg_of res; do rs1 <- ireg_of a1; do rs2 <- ireg_of a2;
      OK (Psll rd rs1 rs2 :: k)
  | Oshlimm n, a1 :: nil =>
      do rd <- ireg_of res; do rs <- ireg_of a1;
      OK (Pslli rd rs n :: k)
  | Oshr, a1 :: a2 :: nil =>
      do rd <- ireg_of res; do rs1 <- ireg_of a1; do rs2 <- ireg_of a2;
      OK (Psra rd rs1 rs2 :: k)
  | Oshrimm n, a1 :: nil =>
      do rd <- ireg_of res; do rs <- ireg_of a1;
      OK (Psrai rd rs n :: k)

  | Oshru, a1 :: a2 :: nil =>
      do rd <- ireg_of res; do rs1 <- ireg_of a1; do rs2 <- ireg_of a2;
      OK (Psrl rd rs1 rs2 :: k)
  | Oshruimm n, a1 :: nil =>
      do rd <- ireg_of res; do rs <- ireg_of a1;
      OK (Psrli rd rs n :: k)

  | Onegf, a1 :: nil =>
      do rd <- freg_of res; do rs <- freg_of a1;
      OK (Pfnegd rd rs :: k)
  | Oabsf, a1 :: nil =>
      do rd <- freg_of res; do rs <- freg_of a1;
      OK (Pfabsd rd rs :: k)
  | Oaddf, a1 :: a2 :: nil =>
      do rd <- freg_of res; do rs1 <- freg_of a1; do rs2 <- freg_of a2;
      OK (Pfaddd rd rs1 rs2 :: k)
  | Osubf, a1 :: a2 :: nil =>
      do rd <- freg_of res; do rs1 <- freg_of a1; do rs2 <- freg_of a2;
      OK (Pfsubd rd rs1 rs2 :: k)
  | Omulf, a1 :: a2 :: nil =>
      do rd <- freg_of res; do rs1 <- freg_of a1; do rs2 <- freg_of a2;
      OK (Pfmuld rd rs1 rs2 :: k)
  | Odivf, a1 :: a2 :: nil =>
      do rd <- freg_of res; do rs1 <- freg_of a1; do rs2 <- freg_of a2;
      OK (Pfdivd rd rs1 rs2 :: k)

  | Onegfs, a1 :: nil =>
      do rd <- freg_of res; do rs <- freg_of a1;
      OK (Pfnegs rd rs :: k)
  | Oabsfs, a1 :: nil =>
      do rd <- freg_of res; do rs <- freg_of a1;
      OK (Pfabss rd rs :: k)
  | Oaddfs, a1 :: a2 :: nil =>
      do rd <- freg_of res; do rs1 <- freg_of a1; do rs2 <- freg_of a2;
      OK (Pfadds rd rs1 rs2 :: k)
  | Osubfs, a1 :: a2 :: nil =>
      do rd <- freg_of res; do rs1 <- freg_of a1; do rs2 <- freg_of a2;
      OK (Pfsubs rd rs1 rs2 :: k)
  | Omulfs, a1 :: a2 :: nil =>
      do rd <- freg_of res; do rs1 <- freg_of a1; do rs2 <- freg_of a2;
      OK (Pfmuls rd rs1 rs2 :: k)
  | Odivfs, a1 :: a2 :: nil =>
      do rd <- freg_of res; do rs1 <- freg_of a1; do rs2 <- freg_of a2;
      OK (Pfdivs rd rs1 rs2 :: k)

  | Osingleoffloat, a1 :: nil =>
      do rd <- freg_of res; do rs <- freg_of a1;
      OK (Pfcvtsd rd rs :: k)
  | Ofloatofsingle, a1 :: nil =>
      do rd <- freg_of res; do rs <- freg_of a1;
      OK (Pfcvtds rd rs :: k)

  | Ointoffloat, a1 :: nil =>
      do rd <- ireg_of res; do rs <- freg_of a1;
      OK (Pfcvtwd rd rs :: k)
  | Ointuoffloat, a1 :: nil =>
      do rd <- ireg_of res; do rs <- freg_of a1;
      OK (Pfcvtwud rd rs :: k)
  | Ofloatofint, a1 :: nil =>
      do rd <- freg_of res; do rs <- ireg_of a1;
      OK (Pfcvtdw rd rs :: k)
  | Ofloatofintu, a1 :: nil =>
      do rd <- freg_of res; do rs <- ireg_of a1;
      OK (Pfcvtdwu rd rs :: k)
  | Ointofsingle, a1 :: nil =>
      do rd <- ireg_of res; do rs <- freg_of a1;
      OK (Pfcvtws rd rs :: k)
  | Ointuofsingle, a1 :: nil =>
      do rd <- ireg_of res; do rs <- freg_of a1;
      OK (Pfcvtwus rd rs :: k)
  | Osingleofint, a1 :: nil =>
      do rd <- freg_of res; do rs <- ireg_of a1;
      OK (Pfcvtsw rd rs :: k)
  | Osingleofintu, a1 :: nil =>
      do rd <- freg_of res; do rs <- ireg_of a1;
      OK (Pfcvtswu rd rs :: k)

  | Ocmp cmp, _ =>
      transl_cond_op cmp args res k

  | _, _ =>
      Error(msg "Asmgen.transl_op")
  end.

(** Accessing data in the stack frame. *)

Definition indexed_memory_access
        (mk_instr: ireg -> int -> instruction)
        (base: ireg) (ofs: int) (k: code) :=
  match make_immed ofs with
  | Imm_single imm => mk_instr base ofs :: k
  | Imm_pair hi lo => load_hibase RA base hi (mk_instr RA lo :: k)
  end.

Definition loadind_int (base: ireg) (ofs: int) (dst: ireg) (k: code) :=
  indexed_memory_access (fun base n => Plw dst base n) base ofs k.

Definition loadind (base: ireg) (ofs: int) (ty: typ) (dst: mreg) (k: code) :=
  match ty, preg_of dst with
  | Tint,    IR rd => OK (indexed_memory_access (fun base n => Plw    rd base n) base ofs k)
  | Tany32,  IR rd => OK (indexed_memory_access (fun base n => Plw_a  rd base n) base ofs k)
  | Tsingle, FR rd => OK (indexed_memory_access (fun base n => Pfls   rd base n) base ofs k)
  | Tfloat,  FR rd => OK (indexed_memory_access (fun base n => Pfld   rd base n) base ofs k)
  | Tany64,  FR rd => OK (indexed_memory_access (fun base n => Pfld_a rd base n) base ofs k)
  | _, _           => Error (msg "Asmgen.loadind")
  end.

Definition storeind (src: mreg) (base: ireg) (ofs: int) (ty: typ) (k: code) :=
  match ty, preg_of src with
  | Tint,    IR rs => OK (indexed_memory_access (fun base n => Psw    rs base n) base ofs k)
  | Tany32,  IR rs => OK (indexed_memory_access (fun base n => Psw_a  rs base n) base ofs k)
  | Tsingle, FR rs => OK (indexed_memory_access (fun base n => Pfss   rs base n) base ofs k)
  | Tfloat,  FR rs => OK (indexed_memory_access (fun base n => Pfsd   rs base n) base ofs k)
  | Tany64,  FR rs => OK (indexed_memory_access (fun base n => Pfsd_a rs base n) base ofs k)
  | _, _           => Error (msg "Asmgen.storeind")
  end.

(** Translation of memory accesses: loads, and stores. *)

Definition transl_memory_access
     (mk_instr: ireg -> int -> instruction)
     (addr: addressing) (args: list mreg) (k: code) :=
  match addr, args with
  | Aindexed ofs, a1 :: nil =>
      do rs <- ireg_of a1;
      OK (match make_immed ofs with
          | Imm_single imm => mk_instr rs imm :: k
          | Imm_pair hi lo => load_hibase RA rs hi (mk_instr RA lo :: k)
          end)
  | Ainstack ofs, nil =>
      OK (match make_immed ofs with
          | Imm_single imm => mk_instr SP imm :: k
          | Imm_pair hi lo => load_hibase RA SP hi (mk_instr RA lo :: k)
          end)
  | _, _ =>
      Error(msg "Asmgen.transl_memory_access")
  end.


Definition transl_load (chunk: memory_chunk) (addr: addressing)
           (args: list mreg) (dst: mreg) (k: code) :=
  match chunk with
  | Mint8signed =>
      do r <- ireg_of dst;
      transl_memory_access (Plb r)  addr args k
  | Mint8unsigned =>
      do r <- ireg_of dst;
      transl_memory_access (Plbu r) addr args k
  | Mint16signed =>
      do r <- ireg_of dst;
      transl_memory_access (Plh r)  addr args k
  | Mint16unsigned =>
      do r <- ireg_of dst;
      transl_memory_access (Plhu r) addr args k
  | Mint32 =>
      do r <- ireg_of dst;
      transl_memory_access (Plw r)  addr args k
  | Mfloat32 =>
      do r <- freg_of dst;
      transl_memory_access (Pfls r) addr args k
  | Mfloat64 =>
      do r <- freg_of dst;
      transl_memory_access (Pfld r) addr args k
  | _ =>
      Error (msg "Asmgen.transl_load")
  end.

Definition transl_store (chunk: memory_chunk) (addr: addressing)
           (args: list mreg) (src: mreg) (k: code) :=
  match chunk with
  | Mint8signed | Mint8unsigned =>
      do r <- ireg_of src;
      transl_memory_access (Psb r)  addr args k
  | Mint16signed | Mint16unsigned =>
      do r <- ireg_of src;
      transl_memory_access (Psh r)  addr args k
  | Mint32 =>
      do r <- ireg_of src;
      transl_memory_access (Psw r)  addr args k
  | Mfloat32 =>
      do r <- freg_of src;
      transl_memory_access (Pfss r) addr args k
  | Mfloat64 =>
      do r <- freg_of src;
      transl_memory_access (Pfsd r) addr args k
  | _ =>
      Error (msg "Asmgen.transl_load")
  end.

(** Translation of a Mach instruction. *)

Definition transl_instr (f: Mach.function) (i: Mach.instruction)
                        (ep: bool) (k: code) :=
  match i with
  | Mgetstack ofs ty dst =>
      loadind SP ofs ty dst k
  | Msetstack src ofs ty =>
      storeind src SP ofs ty k
  | Mgetparam ofs ty dst =>
      (* load via the frame pointer if it is valid *)
      do c <- loadind X30 ofs ty dst k;
      if ep then OK c
      else loadind SP f.(fn_link_ofs) Tint R30 c
  | Mop op args res =>
      transl_op op args res k
  | Mload chunk addr args dst =>
      transl_load chunk addr args dst k
  | Mstore chunk addr args src =>
      transl_store chunk addr args src k
  | Mcall sig (inl r) =>
      do r1 <- ireg_of r; OK (Pj_rl r1 sig :: k)
  | Mcall sig (inr symb) =>
      OK (Pj_sl symb sig :: k)
  | Mtailcall sig (inl r) =>
      do r1 <- ireg_of r;
      OK (loadind_int SP f.(fn_retaddr_ofs) RA
           (Pfreeframe f.(fn_stacksize) f.(fn_link_ofs) :: Pj_r r1 sig :: k))
  | Mtailcall sig (inr symb) =>
      OK (loadind_int SP f.(fn_retaddr_ofs) RA
           (Pfreeframe f.(fn_stacksize) f.(fn_link_ofs) :: Pj_s symb sig :: k))
  | Mbuiltin ef args res =>
      OK (Pbuiltin ef (List.map (map_builtin_arg preg_of) args) (map_builtin_res preg_of res) :: k)
  | Mlabel lbl =>
      OK (Plabel lbl :: k)
  | Mgoto lbl =>
      OK (Pj_l lbl :: k)
  | Mcond cond args lbl =>
      transl_cond cond args lbl k
  | Mjumptable arg tbl =>
      do r <- ireg_of arg;
      OK (Pbtbl r tbl :: k)
  | Mreturn =>
      OK (loadind_int SP f.(fn_retaddr_ofs) RA
            (Pfreeframe f.(fn_stacksize) f.(fn_link_ofs) ::
             Pj_r RA f.(Mach.fn_sig) :: k))
  end.

(** Translation of a code sequence *)

Definition it1_is_parent (before: bool) (i: Mach.instruction) : bool :=
  match i with
  | Msetstack src ofs ty => before
  | Mgetparam ofs ty dst => negb (mreg_eq dst R30)
  | Mop Omove args res => before && negb (mreg_eq res R30)
  | _ => false
  end.

(** This is the naive definition that we no longer use because it
  is not tail-recursive.  It is kept as specification. *)

Fixpoint transl_code (f: Mach.function) (il: list Mach.instruction) (it1p: bool) :=
  match il with
  | nil => OK nil
  | i1 :: il' =>
      do k <- transl_code f il' (it1_is_parent it1p i1);
      transl_instr f i1 it1p k
  end.

(** This is an equivalent definition in continuation-passing style
  that runs in constant stack space. *)

Fixpoint transl_code_rec (f: Mach.function) (il: list Mach.instruction)
                         (it1p: bool) (k: code -> res code) :=
  match il with
  | nil => k nil
  | i1 :: il' =>
      transl_code_rec f il' (it1_is_parent it1p i1)
        (fun c1 => do c2 <- transl_instr f i1 it1p c1; k c2)
  end.

Definition transl_code' (f: Mach.function) (il: list Mach.instruction) (it1p: bool) :=
  transl_code_rec f il it1p (fun c => OK c).

(** Translation of a whole function.  Note that we must check
  that the generated code contains less than [2^32] instructions,
  otherwise the offset part of the [PC] code pointer could wrap
  around, leading to incorrect executions. *)

Definition transl_function (f: Mach.function) :=
  do c <- transl_code' f f.(Mach.fn_code) true;
  OK (mkfunction f.(Mach.fn_sig)
        (Pallocframe f.(fn_stacksize) f.(fn_link_ofs) ::
         Psw RA SP f.(fn_retaddr_ofs) :: c)).  (* TODO: ok if retaddr_ofs < 4K *)

Definition transf_function (f: Mach.function) : res Asm.function :=
  do tf <- transl_function f;
  if zlt Int.max_unsigned (list_length_z tf.(fn_code))
  then Error (msg "code size exceeded")
  else OK tf.

Definition transf_fundef (f: Mach.fundef) : res Asm.fundef :=
  transf_partial_fundef transf_function f.

Definition transf_program (p: Mach.program) : res Asm.program :=
  transform_partial_program transf_fundef p.
